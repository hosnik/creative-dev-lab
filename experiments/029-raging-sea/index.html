<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>029 - Raging Sea</title>
    <style>
        * { margin: 0; padding: 0; }
        html, body { overflow: hidden; }
        canvas { display: block; position: fixed; top: 0; left: 0; outline: none; }
        .info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
        }
        .info h3 { margin-bottom: 10px; color: #00aaff; }
        label { display: block; margin: 5px 0; }
        input[type="range"] { width: 100px; vertical-align: middle; }
        input[type="color"] { vertical-align: middle; cursor: pointer; }
        .highlight { color: #88ccff; }
    </style>
</head>
<body>
    <div class="info">
        <h3>029 - Raging Sea ðŸŒŠ</h3>
        <label>
            <span class="highlight">Big Waves:</span>
            <input type="range" id="bigWaveElevation" min="0" max="0.5" step="0.01" value="0.2">
        </label>
        <label>
            <span class="highlight">Frequency X:</span>
            <input type="range" id="freqX" min="0" max="10" step="0.1" value="4">
        </label>
        <label>
            <span class="highlight">Frequency Z:</span>
            <input type="range" id="freqZ" min="0" max="10" step="0.1" value="1.5">
        </label>
        <label>
            <span class="highlight">Speed:</span>
            <input type="range" id="speed" min="0" max="2" step="0.1" value="0.75">
        </label>
        <label>
            <span class="highlight">Small Waves:</span>
            <input type="range" id="smallWaves" min="0" max="1" step="0.01" value="0.15">
        </label>
        <label>
            <span class="highlight">Deep Color:</span>
            <input type="color" id="deepColor" value="#186691">
        </label>
        <label>
            <span class="highlight">Surface Color:</span>
            <input type="color" id="surfaceColor" value="#9bd8ff">
        </label>
    </div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three'
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

        // Setup
        const canvas = document.createElement('canvas')
        document.body.appendChild(canvas)
        const scene = new THREE.Scene()
        scene.background = new THREE.Color('#001122')
        
        const sizes = { width: window.innerWidth, height: window.innerHeight }
        const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)
        camera.position.set(1, 1, 1.5)
        scene.add(camera)

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true })
        renderer.setSize(sizes.width, sizes.height)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

        const controls = new OrbitControls(camera, canvas)
        controls.enableDamping = true

        // ============================================
        // RAGING SEA SHADER
        // ============================================

        const vertexShader = `
            uniform float uTime;
            uniform float uBigWavesElevation;
            uniform vec2 uBigWavesFrequency;
            uniform float uBigWavesSpeed;
            uniform float uSmallWavesElevation;
            uniform float uSmallWavesFrequency;
            uniform float uSmallWavesSpeed;
            uniform float uSmallIterations;

            varying float vElevation;
            varying vec3 vNormal;
            varying vec3 vPosition;

            // Classic Perlin 3D Noise (simplified)
            vec4 permute(vec4 x) {
                return mod(((x * 34.0) + 1.0) * x, 289.0);
            }
            vec4 taylorInvSqrt(vec4 r) {
                return 1.79284291400159 - 0.85373472095314 * r;
            }
            vec3 fade(vec3 t) {
                return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
            }

            float cnoise(vec3 P) {
                vec3 Pi0 = floor(P);
                vec3 Pi1 = Pi0 + vec3(1.0);
                Pi0 = mod(Pi0, 289.0);
                Pi1 = mod(Pi1, 289.0);
                vec3 Pf0 = fract(P);
                vec3 Pf1 = Pf0 - vec3(1.0);
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz;
                vec4 iz1 = Pi1.zzzz;

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 / 7.0;
                vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 / 7.0;
                vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);
                vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);
                vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);
                vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);
                vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);
                vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);
                vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);
                vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return 2.2 * n_xyz;
            }

            void main() {
                vec4 modelPosition = modelMatrix * vec4(position, 1.0);

                // Big waves
                float elevation = sin(modelPosition.x * uBigWavesFrequency.x + uTime * uBigWavesSpeed) *
                                 sin(modelPosition.z * uBigWavesFrequency.y + uTime * uBigWavesSpeed) *
                                 uBigWavesElevation;

                // Small waves (noise-based)
                for(float i = 1.0; i <= uSmallIterations; i++) {
                    elevation -= abs(cnoise(vec3(
                        modelPosition.xz * uSmallWavesFrequency * i,
                        uTime * uSmallWavesSpeed
                    )) * uSmallWavesElevation / i);
                }

                modelPosition.y += elevation;

                vec4 viewPosition = viewMatrix * modelPosition;
                vec4 projectedPosition = projectionMatrix * viewPosition;
                
                gl_Position = projectedPosition;

                // Varyings
                vElevation = elevation;
                vPosition = modelPosition.xyz;
            }
        `

        const fragmentShader = `
            uniform vec3 uDepthColor;
            uniform vec3 uSurfaceColor;
            uniform float uColorOffset;
            uniform float uColorMultiplier;

            varying float vElevation;
            varying vec3 vPosition;

            void main() {
                // Color based on elevation
                float mixStrength = (vElevation + uColorOffset) * uColorMultiplier;
                mixStrength = clamp(mixStrength, 0.0, 1.0);
                
                vec3 color = mix(uDepthColor, uSurfaceColor, mixStrength);
                
                // Add foam on peaks
                float foam = smoothstep(0.1, 0.2, vElevation);
                color = mix(color, vec3(1.0), foam * 0.3);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `

        // Shader Material
        const waterMaterial = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uBigWavesElevation: { value: 0.2 },
                uBigWavesFrequency: { value: new THREE.Vector2(4, 1.5) },
                uBigWavesSpeed: { value: 0.75 },
                uSmallWavesElevation: { value: 0.15 },
                uSmallWavesFrequency: { value: 3 },
                uSmallWavesSpeed: { value: 0.2 },
                uSmallIterations: { value: 4 },
                uDepthColor: { value: new THREE.Color('#186691') },
                uSurfaceColor: { value: new THREE.Color('#9bd8ff') },
                uColorOffset: { value: 0.08 },
                uColorMultiplier: { value: 5 }
            },
            side: THREE.DoubleSide
        })

        // Water geometry
        const waterGeometry = new THREE.PlaneGeometry(3, 3, 512, 512)
        const water = new THREE.Mesh(waterGeometry, waterMaterial)
        water.rotation.x = -Math.PI / 2
        scene.add(water)

        // ============================================
        // UI CONTROLS
        // ============================================
        document.getElementById('bigWaveElevation').addEventListener('input', (e) => {
            waterMaterial.uniforms.uBigWavesElevation.value = parseFloat(e.target.value)
        })
        document.getElementById('freqX').addEventListener('input', (e) => {
            waterMaterial.uniforms.uBigWavesFrequency.value.x = parseFloat(e.target.value)
        })
        document.getElementById('freqZ').addEventListener('input', (e) => {
            waterMaterial.uniforms.uBigWavesFrequency.value.y = parseFloat(e.target.value)
        })
        document.getElementById('speed').addEventListener('input', (e) => {
            waterMaterial.uniforms.uBigWavesSpeed.value = parseFloat(e.target.value)
        })
        document.getElementById('smallWaves').addEventListener('input', (e) => {
            waterMaterial.uniforms.uSmallWavesElevation.value = parseFloat(e.target.value)
        })
        document.getElementById('deepColor').addEventListener('input', (e) => {
            waterMaterial.uniforms.uDepthColor.value.set(e.target.value)
        })
        document.getElementById('surfaceColor').addEventListener('input', (e) => {
            waterMaterial.uniforms.uSurfaceColor.value.set(e.target.value)
        })

        // Resize
        window.addEventListener('resize', () => {
            sizes.width = window.innerWidth
            sizes.height = window.innerHeight
            camera.aspect = sizes.width / sizes.height
            camera.updateProjectionMatrix()
            renderer.setSize(sizes.width, sizes.height)
        })

        // Animation
        const clock = new THREE.Clock()
        const tick = () => {
            const elapsedTime = clock.getElapsedTime()
            waterMaterial.uniforms.uTime.value = elapsedTime
            controls.update()
            renderer.render(scene, camera)
            requestAnimationFrame(tick)
        }
        tick()

        // ============================================
        // LEARNINGS SUMMARY
        // ============================================
        /*
        RAGING SEA SHADER TECHNIQUES:

        1. LAYERED WAVES:
           - Big waves: sin() functions for main shape
           - Small waves: Perlin noise for organic detail
           - Combine multiple octaves (iterations)

        2. WAVE FORMULA:
           elevation = sin(x * freqX + time * speed) *
                      sin(z * freqZ + time * speed) *
                      amplitude

        3. NOISE LAYERING (FBM - Fractal Brownian Motion):
           for(i = 1; i <= iterations; i++) {
               elevation += noise(pos * freq * i) * amp / i;
           }
           - Higher i = finer detail, less amplitude

        4. COLOR BY ELEVATION:
           mixStrength = (elevation + offset) * multiplier;
           color = mix(deepColor, surfaceColor, mixStrength);

        5. FOAM EFFECT:
           foam = smoothstep(threshold, threshold + range, elevation);
           color = mix(color, white, foam * intensity);

        6. PERLIN NOISE:
           - Continuous, smooth randomness
           - 3D noise allows time-based animation
           - cnoise(vec3(x, z, time))

        7. HIGH RESOLUTION NEEDED:
           - PlaneGeometry(3, 3, 512, 512)
           - More segments = smoother waves
           - But more GPU cost

        8. PERFORMANCE TIP:
           - uSmallIterations controls noise octaves
           - Less iterations = faster but less detail
        */
    </script>
</body>
</html>
