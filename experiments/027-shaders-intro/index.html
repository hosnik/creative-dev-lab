<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>027 - Shaders Introduction</title>
    <style>
        * { margin: 0; padding: 0; }
        html, body { overflow: hidden; }
        canvas { display: block; position: fixed; top: 0; left: 0; outline: none; }
        .info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            max-width: 320px;
        }
        .info h3 { margin-bottom: 10px; color: #ff00ff; font-size: 14px; }
        .info p { margin: 4px 0; }
        .highlight { color: #00ffff; }
        .section { margin-top: 10px; border-top: 1px solid #444; padding-top: 8px; }
        code { background: #333; padding: 2px 5px; border-radius: 3px; font-size: 11px; }
    </style>
</head>
<body>
    <div class="info">
        <h3>027 - Shaders Introduction</h3>
        <p>Custom GLSL shaders running on GPU</p>
        
        <div class="section">
            <p class="highlight">Vertex Shader:</p>
            <p>Positions each vertex in clip space</p>
            <p>Output: <code>gl_Position</code></p>
        </div>
        
        <div class="section">
            <p class="highlight">Fragment Shader:</p>
            <p>Colors each pixel/fragment</p>
            <p>Output: <code>gl_FragColor</code></p>
        </div>
        
        <div class="section">
            <p class="highlight">Data Flow:</p>
            <p><code>attribute</code> → vertex only (per-vertex)</p>
            <p><code>uniform</code> → both (same for all)</p>
            <p><code>varying</code> → vertex → fragment</p>
        </div>
        
        <div class="section">
            <p style="font-size: 10px; color: #888;">
                Wave animation via vertex shader.<br>
                Color gradient via fragment shader.<br>
                Time passed as uniform.
            </p>
        </div>
    </div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three'
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

        // Canvas & Scene
        const canvas = document.createElement('canvas')
        document.body.appendChild(canvas)
        const scene = new THREE.Scene()

        // Sizes
        const sizes = {
            width: window.innerWidth,
            height: window.innerHeight
        }

        // Camera
        const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)
        camera.position.set(1, 1, 2)
        scene.add(camera)

        // Renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true })
        renderer.setSize(sizes.width, sizes.height)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        renderer.setClearColor('#0a0a15')

        // Controls
        const controls = new OrbitControls(camera, canvas)
        controls.enableDamping = true

        // ============================================
        // VERTEX SHADER
        // ============================================
        // Runs once per vertex
        // Purpose: Position the vertex in clip space
        // Output: gl_Position (vec4)
        const vertexShader = `
            // UNIFORMS - same for all vertices
            uniform float uTime;
            uniform float uWaveFrequency;
            uniform float uWaveAmplitude;
            
            // ATTRIBUTES - built-in from BufferGeometry
            // attribute vec3 position;  // Already available
            // attribute vec2 uv;        // Already available
            // attribute vec3 normal;    // Already available
            
            // VARYINGS - pass to fragment shader
            varying vec2 vUv;
            varying float vElevation;
            
            void main() {
                // Model position
                vec4 modelPosition = modelMatrix * vec4(position, 1.0);
                
                // Wave effect - modify Y based on X and time
                float elevation = sin(modelPosition.x * uWaveFrequency + uTime) * uWaveAmplitude;
                elevation += sin(modelPosition.z * uWaveFrequency * 0.5 + uTime * 0.8) * uWaveAmplitude * 0.5;
                
                modelPosition.y += elevation;
                
                // View position
                vec4 viewPosition = viewMatrix * modelPosition;
                
                // Projected position (clip space)
                vec4 projectedPosition = projectionMatrix * viewPosition;
                
                // OUTPUT - required!
                gl_Position = projectedPosition;
                
                // Pass to fragment shader
                vUv = uv;
                vElevation = elevation;
            }
        `

        // ============================================
        // FRAGMENT SHADER
        // ============================================
        // Runs once per pixel/fragment
        // Purpose: Determine the color of each pixel
        // Output: gl_FragColor (vec4 - RGBA)
        const fragmentShader = `
            // UNIFORMS
            uniform float uTime;
            uniform vec3 uColorA;
            uniform vec3 uColorB;
            
            // VARYINGS - received from vertex shader (interpolated!)
            varying vec2 vUv;
            varying float vElevation;
            
            void main() {
                // Mix colors based on UV and elevation
                float mixStrength = (vElevation + 0.1) * 5.0;
                mixStrength = clamp(mixStrength, 0.0, 1.0);
                
                vec3 color = mix(uColorA, uColorB, mixStrength);
                
                // Add some variation based on UV
                color += vUv.x * 0.1;
                
                // OUTPUT - required!
                gl_FragColor = vec4(color, 1.0);
            }
        `

        // ============================================
        // SHADER MATERIAL
        // ============================================
        const shaderMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                // Values passed to shaders
                uTime: { value: 0 },
                uWaveFrequency: { value: 4.0 },
                uWaveAmplitude: { value: 0.15 },
                uColorA: { value: new THREE.Color('#ff00ff') },  // Magenta
                uColorB: { value: new THREE.Color('#00ffff') }   // Cyan
            },
            // Optional: wireframe, transparent, side, etc.
            // wireframe: true
        })

        // ============================================
        // GEOMETRY
        // ============================================
        const geometry = new THREE.PlaneGeometry(2, 2, 128, 128)
        const mesh = new THREE.Mesh(geometry, shaderMaterial)
        mesh.rotation.x = -Math.PI / 2
        scene.add(mesh)

        // Second mesh - sphere with same shader
        const sphereGeometry = new THREE.SphereGeometry(0.5, 64, 64)
        const sphere = new THREE.Mesh(sphereGeometry, shaderMaterial.clone())
        sphere.position.set(0, 0.8, 0)
        sphere.material.uniforms.uWaveAmplitude.value = 0.1
        scene.add(sphere)

        // ============================================
        // RESIZE
        // ============================================
        window.addEventListener('resize', () => {
            sizes.width = window.innerWidth
            sizes.height = window.innerHeight
            camera.aspect = sizes.width / sizes.height
            camera.updateProjectionMatrix()
            renderer.setSize(sizes.width, sizes.height)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        })

        // ============================================
        // ANIMATION
        // ============================================
        const clock = new THREE.Clock()

        const tick = () => {
            const elapsedTime = clock.getElapsedTime()

            // Update shader uniforms
            shaderMaterial.uniforms.uTime.value = elapsedTime
            sphere.material.uniforms.uTime.value = elapsedTime

            controls.update()
            renderer.render(scene, camera)
            requestAnimationFrame(tick)
        }

        tick()

        // ============================================
        // LEARNINGS SUMMARY
        // ============================================
        /*
        SHADER FUNDAMENTALS:

        1. WHAT ARE SHADERS?
           - Programs that run on the GPU (very fast, parallel)
           - Written in GLSL (OpenGL Shading Language)
           - C-like syntax, strict typing

        2. TWO TYPES:
           
           VERTEX SHADER:
           - Runs once per vertex
           - Purpose: Position vertices in clip space
           - Can modify vertex positions (animations, morphing)
           - Output: gl_Position (required!)
           
           FRAGMENT SHADER:
           - Runs once per pixel (fragment)
           - Purpose: Determine pixel color
           - Output: gl_FragColor (required!)

        3. DATA TYPES:
           float     - single precision decimal
           int       - integer
           vec2      - 2 floats (x, y) or (r, g)
           vec3      - 3 floats (x, y, z) or (r, g, b)
           vec4      - 4 floats (x, y, z, w) or (r, g, b, a)
           mat2/3/4  - matrices
           sampler2D - texture reference

        4. QUALIFIERS:
           
           attribute - per-vertex data (vertex shader only)
                      Examples: position, uv, normal
           
           uniform   - same value for all vertices/fragments
                      Set from JavaScript
                      Examples: uTime, uColor, uTexture
           
           varying   - passes data from vertex to fragment shader
                      Gets interpolated across the surface!

        5. BUILT-IN ATTRIBUTES (from BufferGeometry):
           position  - vec3
           uv        - vec2
           normal    - vec3

        6. BUILT-IN UNIFORMS (from Three.js):
           modelMatrix      - object transforms
           viewMatrix       - camera view
           projectionMatrix - camera projection
           modelViewMatrix  - model * view combined
           normalMatrix     - for normal transformations

        7. TYPICAL VERTEX SHADER FLOW:
           vec4 modelPosition = modelMatrix * vec4(position, 1.0);
           // modify modelPosition here
           vec4 viewPosition = viewMatrix * modelPosition;
           vec4 projectedPosition = projectionMatrix * viewPosition;
           gl_Position = projectedPosition;

        8. COMMON FUNCTIONS:
           sin(), cos(), abs(), min(), max()
           mix(a, b, t)     - linear interpolation
           clamp(x, min, max)
           step(edge, x)    - returns 0 or 1
           smoothstep(a, b, x)
           length(), distance(), dot(), cross()
           normalize()

        9. THREE.JS INTEGRATION:
           new THREE.ShaderMaterial({
               vertexShader: '...',
               fragmentShader: '...',
               uniforms: {
                   uTime: { value: 0 }
               }
           })
           
           // Update uniform:
           material.uniforms.uTime.value = elapsedTime
        */
    </script>
</body>
</html>
